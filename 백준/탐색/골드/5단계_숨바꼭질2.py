"""
숨바꼭질 2 성공
시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
2 초	512 MB	56633	15868	11048	25.615%

문제
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다.
수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다.
순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 그리고,
가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램을 작성하시오.

입력
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

출력
첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수를 출력한다.

예제 입력 1
5 17
예제 출력 1
4
2

포인트
1. visitied를 만들어 첫번째에는 몇초걸렸는지 넣어주고 두번째에는 횟수를 넣어준다. 초기세팅값은 [-1,0]
2. 처음 접근할때는 인덱스0번에 +1을 해주고 q에쌓고 횟수 +1 해준다
3. 다시 같은번호로 또 접근시에는 이미 한번접근한 이력이 있으므로 같은초가 걸린 요소(인덱스 1번)에 횟수만 +1 해준다
"""


from collections import deque

n, k = map(int, input().split())


def bfs():
    q = deque()
    q.append(n)
    visited = [[-1, 0] for _ in range(100001)]
    visited[n] = [0, 1]  # 5가 시작번호이므로 0,1 로 세팅해준다

    while q:
        tmp = q.popleft()
        current_time, count = visited[tmp]
        for i in [tmp + 1, tmp - 1, tmp * 2]:
            if 0 <= i < 100001:
                next_time = current_time + 1
                # 한번도 방문하지 않았을경우 or 방문했던 요소인데 같은 초가걸린 요소일경우
                if visited[i][0] == -1 or visited[i][0] == next_time:
                    if visited[i][0] == -1:  # 처음접근할때만 q에 쌓는다 이유는 다시접근하면 이미 해당번호로 bfs수행했기 때문
                        q.append(i)
                        visited[i][0] = next_time
                    visited[i][1] += count  # 횟수 증가시켜준다
    return visited[k][0], visited[k][1]


time, cnt = bfs()
print(time)
print(cnt)
